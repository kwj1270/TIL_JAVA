

**람다식 코드**
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

public class ArrangeList {
    public static void main(String[] args) {
        List<Integer> list  = Arrays.asList(1,3,5,7,9);
        list = new ArrayList<>(list);

        Consumer<List<Integer>> c = val -> Collections.reverse(val); // 여기서 val은 단지 전달만된다.      
        c.accept(list);        
        System.out.println(list);    
    }   
      
}
```  

**메서드 레퍼런스 코드**   
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

public class ArrangeList {
    public static void main(String[] args) {
        List<Integer> list  = Arrays.asList(1,3,5,7,9);
        list = new ArrayList<>(list);

        Consumer<List<Integer>> c = Collections::reverse;
        c.accept(list); 
        System.out.println(list);
    }

}
```  
위 예시와 같이      
**람다의 인자값이 다른 메서드의 인자값으로 그대로 사용될 경우 이를 생략 가능하다**         
       
**람다식 코드**
```java
import java.util.function.ToIntBiFunction;

class MyBox{
    int number;
    public MyBox(int number){
        this.number = number;
    }
    public int lager(MyBox other){
        if(this.number >= other.number) return this.number;
        return other.number;
    }
}

public class ToIntBiFunctionTest {
    public static void main(String[] args) {
        MyBox myBox1 = new MyBox(1);
        MyBox myBox2 = new MyBox(2);

        ToIntBiFunction<MyBox, MyBox> bf = (box1, box2) -> box1.lager(box2);
        
    }

}
```  
    
**메서드 레퍼런스 코드**   
```java
import java.util.function.ToIntBiFunction;

class MyBox{
    int number;
    public MyBox(int number){
        this.number = number;
    }
    public int lager(MyBox other){
        if(this.number >= other.number) return this.number;
        return other.number;
    }
}

public class ToIntBiFunctionTest {
    public static void main(String[] args) {
        MyBox myBox1 = new MyBox(1);
        MyBox myBox2 = new MyBox(2);

        ToIntBiFunction<MyBox, MyBox> bf = MyBox::lager;

    }

}
```
**람다의 매개변수 중 하나가 다른 매개변수를 또 매개변수로 사용할 때 생략가능하다**     
 

### static 메서드 참조    

**람다식 코드**
```java
import java.util.function.Function;

public class StaticTest {
    public static void main(String[] args) {
        Function<String, Integer> f = s -> Integer.parseInt(s);
        System.out.println(f.apply("2").getClass().getName());
    }
}
```

**메서드 참조 코드**   
```java
import java.util.function.Function;

public class ArrangeList {
    public static void main(String[] args) {
        Function<String, Integer> f = Integer::parseInt;
        System.out.println(f.apply("2").getClass().getName());
    }
}
/* 실행 결과 
 *
 * java.lang.Integer
 *
 */
```
`Integer`의 `parseInt()`는 `static 메서드`이다.      
이 같은 `static 메서드`는 `클래스이름 ::메서드`형태로 메서들 레퍼런스를 작성하면 된다.    

### 외부 영역 인스턴스의 메서드 레퍼런스      
**람다식 코드**
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

class JustSort{
    public void sort(List<?> list){
        Collections.reverse(list);
    }
}

public class ArrangeList3 {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1,3,5,7,9);
        list = new ArrayList<>(list);
        JustSort justSort = new JustSort();

        Consumer<List<Integer>> c = e -> justSort.sort(e);
        c.accept(list);
        System.out.println(list);
    }
}
```

**메서드 참조 코드**   
```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

class JustSort{
    public void sort(List<?> list){
        Collections.reverse(list);
    }
}

public class ArrangeList3 {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1,3,5,7,9);
        list = new ArrayList<>(list);
        JustSort justSort = new JustSort();

        Consumer<List<Integer>> c = justSort::sort;
        c.accept(list);
        System.out.println(list);
    }
}
```   
다른 영역에 존재하는 인스턴스를 통해서도 메서드 레퍼런스를 진행할 수 있다.   

### 클래스 이름을 통한 인스턴스 메서드 참조        
**람다식 코드**
```java
import java.util.function.ToIntBiFunction;

class MyBox{
    int number;
    public MyBox(int number){
        this.number = number;
    }
    public int lager(MyBox other){
        if(this.number >= other.number) return this.number;
        return other.number;
    }
}

public class ToIntBiFunctionTest {
    public static void main(String[] args) {
        MyBox myBox1 = new MyBox(1);
        MyBox myBox2 = new MyBox(2);

        ToIntBiFunction<MyBox, MyBox> bf = (box1, box2) -> box1.lager(box2);
        
    }

}
```  
    
**메서드 참조 코드**   
```java
import java.util.function.ToIntBiFunction;

class MyBox{
    int number;
    public MyBox(int number){
        this.number = number;
    }
    public int lager(MyBox other){
        if(this.number >= other.number) return this.number;
        return other.number;
    }
}

public class ToIntBiFunctionTest {
    public static void main(String[] args) {
        MyBox myBox1 = new MyBox(1);
        MyBox myBox2 = new MyBox(2);

        ToIntBiFunction<MyBox, MyBox> bf = MyBox::lager;

    }

}
```
앞서 위에서 봤던 코드다.    
`참조변수를 통한 인스턴스 메서드 참조` 는 외부에서 인스턴스 변수의 메서드를 호출할 때를 의미하고      
`클래스 이름을 통한 인스턴스 메서드 참조`는 **내부 매개변수의 메서드를 호출할 때를 의미한다.**        
그리고 이 모든 공통점은 **메서드가 1개밖에 없다는 것이다**    

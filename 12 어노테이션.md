# 들어가면서 
> 목표 : 자바의 애노테이션에 대해 학습하세요.

애노테이션 정의하는 방법
@retention
@target
@documented
애노테이션 프로세서
마감일시


애노테이션 정의하는 방법
@retention
@target
@documented
애노테이션 프로세서
마감일시

# 어노테이션이란?    
자바 어노테이션은 `JDK 5`부터 추가된 기능으로      
소스코드에 **추가적인 정보를 제공하는 `메타 데이터`** 이다.         
    
**`메타 데이타`** 이기 때문에 **비즈니스 로직에 직접적인 영향을 주지 않지만,**                
이 메타데이터 정보에 따라서 **실행 흐름을 변경할 수 있는 코딩이 가능하여**                        
단지 어노테이션 추가만으로 **더 깔끔한 코딩이 가능**해질 수 있다.       
   
**메타데이터**
```
데이터에 대한 데이터이다.(데이터를 위한 데이터라고도 말한다.)                     
즉, 특정 데이터에 대한 설명을 의미하는 데이터. (자신의 정보를 담고 있는 데이터)        
```    
___    
   
![화면 캡처 2021-01-31 133936](https://user-images.githubusercontent.com/50267433/106374821-d7800600-63c9-11eb-8059-933ee0b19027.png)   
![화면 캡처 2021-01-31 133853](https://user-images.githubusercontent.com/50267433/106374818-cd5e0780-63c9-11eb-9a12-8582a61ae89b.png)   
     
예를 들면, `@FunctaionalInterface`는 인터페이스의 추상 메서드를 1개로 제한한다.           
그렇기에 개발자들은 해당 어노테이션 제약조건에 맞춰서 코딩을 진행해야한다.         
   
___
   
**어노테이션의 용도**   
- `@Override` 어노테이션처럼 **컴파일러를 위한 정보를 제공**하기 위한 용도   
- 스프링 프레임워크의 `@Controller` 어노테이션처럼           
런타임에 리플렉션을 이용해서 **특수 기능을 추가**하기 위한 용도            
- **컴파일 과정에서** 어노테이션 정보로부터 **코드를 생성**하기 위한 용도 (`@Getter`/`@Setter`)       
        
**어노테이션 범위**
* 패키지   
* 클래스    
* 생성자  
* 메서드    
* 필드 변수     
* 지역변수  
* 파라미터   
  

# 어노테이션 정의하는 방법      
어노테이션은 크게 3가지로 구분된다.        
   
1. 마커 어노테이션 (Maker Annotation)     
2. 싱글 값 어노테이션 (Single Value Annotation)    
3. 멀티 값 어노테이션 (Multi Value Annotation)   

## 마커 어노테이션 (Maker Annotation) 


```java
@interface MakerAnnotation {}

@MakerAnnotation                           
public class UsingMakerAnnotation {}
```


## 싱글 값 어노테이션 (Single Value Annotation)
## 멀티 값 어노테이션 (Multi Value Annotation)   


# @Retention  
    
![image](https://user-images.githubusercontent.com/50267433/106376415-76abfa00-63d8-11eb-9b28-c3290aaa35ff.png)
      
어느 시점까지 어노테이션의 메모리를 가져갈 지 설정하는 것으로,      
일종의 어노테이션의 범위(?)라고도 말할 수 있다.            
즉, **어느 시점까지 어노테이션이 영향을 미치는지 결정한다.**                 
        
`Retention`어노테이션의 `()`에 들어올 수 있는 값은 `RetentionPolicy` 타입이다.          
   
![image](https://user-images.githubusercontent.com/50267433/106376438-ac50e300-63d8-11eb-82f1-345ef761b842.png)
`RetentionPolicy`은 enum 타입으로 `SOURCE`, `CLASS`, `RUNTIME` 상수가 존재한다.     


|상수|설명|
|----|---|
|RetentionPolicy.SOURCE|소스 코드에서만 사용할 수 있으며 컴파일시에 메모리가 제거된다.<br>사실상, 어노테이션을 주석처럼 사용하는 경우|    
|RetentionPolicy.CLASS|컴파일시에는 컴파일러가 어노테이션의 메모리를 가져가지만 실질적으로 런타임시에는 사라진다.<br>런타임시에 사라진다는 것은 리플렉션으로 선언된 어노테이션 데이터를 가져올 수 없게 되는 것을 의미한다.<br>`@Retention`을 선언하지 않았을 경우 설정되는 디폴트값이다.|       
|RetentionPolicy.RUNTIME|어노테이션을 런타임까지 사용할 수 있다.<br>JVM이 `.class` 파일에서 런타임환경을 구성하고 런타임을 종료할 때까지 메모리는 살아있다.<br>리플렉션으로 선언된 어노테이션 데이터를 가져올 수 있다.|      
    
 

# @target
어노테이션이 생성될 수 있는 위치를 지정한다.         



# @documented  
`@Documented`는 메타 데이터 어노테이션이다.           
어노테이션을 정의할 때 `@documented` 형태로 적용하여,     
해당 어노테이션을 사용하는 클래스가 javadoc과 같은 문서화 될 때,  
해당 어노테이션이 적용되었음을 명시하도록 한다.    

```java
@Documented   
@Inherited  // @Documented 사용하는 클래스의 하위 클래스에도 자동으로 적용       
@Retention(RetentionPolicy.RUNTIME) // 어느 시점까지 어노테이션의 메모리를 가져갈 지 설정,  
public @interface InWork {
    String value();
}
```
```java
@InWork(value = "")
public class MainApp {...}
```
![image](https://user-images.githubusercontent.com/50267433/106375599-c2f33c00-63d0-11eb-8899-85026110ebd5.png)    
* 이미지 출처 : https://stackoverflow.com/questions/5592703/documented-annotation-in-java/20432882





# 어노테이션 프로세서

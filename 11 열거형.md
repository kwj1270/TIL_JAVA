# 들어가면서  
> 목표 : 자바의 열거형에 대해 학습하세요.
   
enum 정의하는 방법  
enum이 제공하는 메소드    
java.lang.Enum     
EnumSet   
   
enum 정의하는 방법   
enum이 제공하는 메소드 (values()와 valueOf())   
java.lang.Enum  
EnumSet  
       
# enum 이란?     
> Enumerated type : 열거형 타입      

```java           
enum DisplayType {
    CRT("Cathode Ray Tube"),
    FPD("Flat Panel Display"),
    LCD("Liquid Crystal Display"),
    PDP("Plasma Display Panel"),
    LED("Light emitting diode"),
    OLED("Organic Light Emitting Diode");

    private final String key;

    public String getKey() {
        return key;
    }

    DisplayType(String key) {
        this.key = key;
    }
}
```
`enum`이란 `enumerated type`의 줄임말로                   
**멤버**라 불리는 명명된 값의 **집합**을 이루는 자료형이다.             
즉, 열거형에 사용될 수 있는 특정한 값들을 정의해서 해당 값들만 사용할 수 있게 한다.                        
참고로, 열거자 이름들은 일반적으로 해당 언어의 **상수** 역할을 하는 식별자이다.           
      
# enum 정의하는 방법   
## 일반적인 생성 방법
```java
enum 열거형이름 {상수명1, 상수명2, ...}
```
```java
enum Kind{ CLOVER, HEART, DIAMOND, SPADE}
```
열거형을 정의하는 방법은 간단하다.        
괄호`{}` 안에 상수의 이름을 나열하기만 하면 된다.   

```java
public class EnumTest {
    private int x = 0;
    private int y = 0;

    public void move2(Direction direction) {
        if(direction == Direction.EAST){
            ++y;
        }
        if(direction == Direction.WEST){
            --y;
        }
        if(direction == Direction.SOUTH){
            --x;
        }
        if(direction == Direction.NORTH){
            ++x;
        }
    }
    
    public void move(Direction direction) {
        switch (direction){
            case EAST:
                ++y;
                break;
            case WEST:
                --y;
                break;
            case SOUTH:
                --x;
                break;
            case NORTH:
                ++x;
                break;
        }
    }
}
```
`if`구문을 사용해도 되고,      
`switch-case`문을 이용해서 각 상수 값마다 다른 로직을 처리하게 할 수 있다.            
참고로 `switch-case`문을 이용할 때는 상수의 이름만 적어야 한다.      
           
열거형의 정의와 사용은 언뜻보면 쉬워보인다.         
하지만, 위에서 소개된 방법으로는 상수는 아무런 값을 가지지 않는다.        
즉, 우리는 enum의 가장 간단한 방법만 배웠을 뿐 더 효과적인 방법이 여럿 존재한다.      
아래에서는 enum에 의미를 부여해서 이를 활용하는 방법을 설명해보겠다.      
    
## 값을 가진 Enum   
```java
enum 열거형이름 {
  상수명(),    // 생성자 호출   
  상수명(),    // 생성자 호출    
  상수명()     // 생성자 호출  
    
  private final [데이터타입] [변수이름];     // [접근지정자] [final] 는 설정할 수 있지만,     
                                           // private final 을 사용하는 것이 일반적이다.         
  
  public get변수이름() {
      return 변수이름;
  }
  
  열거형이름-생성자(매개변수..) {
      변수 = 값;
  }
    
}
```  
열거형 **상수에 `()`** 를 붙여, 값을 부여할 수 있다.             
`()`안에는 프리미티브 타입 데이터는 물론, 레퍼런스 타입 객체도 들어올 수 있다.             
단, 열거형 상수에 값을 부여할 경우, 이에 해당하는 **생성자도 함께 정의해줘야 한다.**      
   
```java
enum Kind{ CLOVER, HEART, DIAMOND, SPADE} // 디폴트 생성자 사용 
```
사실, 앞서 배웠던 방법에서 생성자를 정의하지 않았던 이유는       
자동으로 생성되는 **디폴트 생성자를 사용했기 때문이다.**        

```java
enum 열거형이름 {

    상수명(),    // 생성자 호출   
    상수명(),    // 생성자 호출    
    상수명()     // 생성자 호출  
  
    [접근지정자] [final] [데이터타입] [변수이름];
  
    열거형이름-생성자(매개변수..) {
        변수 = 값;
    }
  
}  
```
그리고 추가로 알 수 있는 점은 상수를 선언하는 것은      
동시에 생성자를 호출하는 것임을 알 수 있다.       
          
그렇기 때문에, 상수에 값을 부여하는 것은            
`()`에 해당하는 매개변수를 가진 생성자를 호출하는 것이며     
매개변수로 들어올 데이터를 저장할 변수도 선언해주는 것이다.   
  
```java
  private final [데이터타입] [변수이름];
  
  public get변수이름() {
      return 변수이름;
  }
```
상수의 의미를 저장할 데이터는 접근 지정자를 선택할 수 있다.     
하지만, `public`으로 선언시에는 외부에서 자유롭게 호출하므로    
캡슐화가 깨진다는 문제가 있다.       
   
그렇기 때문에, `private` 접근 지정자를 주고,        
`getter` 메서드를 생성해주는 방식을 주로 사용하고 있다.            
     
**예제**
```java
enum DisplayType {
    CRT("Cathode Ray Tube"),
    FPD("Flat Panel Display"),
    LCD("Liquid Crystal Display"),
    PDP("Plasma Display Panel"),
    LED("Light emitting diode"),
    OLED("Organic Light Emitting Diode");

    private final String key;

    public String getKey() {
        return key;
    }

    DisplayType(String key) {
        this.key = key;
    }
}

public class EnumTest {
    public static void main(String[] args) {
        System.out.println(DisplayType.OLED);
    }
}
```  
     
<img width="1062" alt="스크린샷 2021-01-24 오후 2 58 50" src="https://user-images.githubusercontent.com/50267433/105622736-2c1a0300-5e57-11eb-9db1-dfeca0a197b6.png">  
  
    
* `controll + space` 자동완성 기능을 사용해보면           
나열된 상수값과 메서드만 사용할 수 있다는 것을 알 수 있다.          
    
<img width="1062" alt="스크린샷 2021-01-24 오후 2 59 10" src="https://user-images.githubusercontent.com/50267433/105622742-3fc56980-5e57-11eb-872c-05dff0378706.png">  
   

* 나열된 상수값이 아닌 새로운 값을 넣으면 컴파일 에러가 발생한다.    
    
<img width="1062" alt="스크린샷 2021-01-24 오후 2 59 19" src="https://user-images.githubusercontent.com/50267433/105622756-58ce1a80-5e57-11eb-9eda-bf646a38ab16.png">  
  
   
* 나열된 상수값을 통해 올바른 값을 넣어주자  

## import static을 이용한 간략화       
<img width="1062" alt="스크린샷 2021-01-24 오후 2 59 39" src="https://user-images.githubusercontent.com/50267433/105622768-6aafbd80-5e57-11eb-85e9-5f049ac309e8.png">  
    
    
```java
import static study.eenum.DisplayType.*;

enum DisplayType {
    CRT("Cathode Ray Tube"),
    FPD("Flat Panel Display"),
    LCD("Liquid Crystal Display"),
    PDP("Plasma Display Panel"),
    LED("Light emitting diode"),
    OLED("Organic Light Emitting Diode");

    private final String key;

    public String getKey() {
        return key;
    }

    DisplayType(String key) {
        this.key = key;
    }
}

public class EnumTest {
    public static void main(String[] args) {
        System.out.println(OLED);
    }
}
```
`import static` 을 이용하면 '열거형 상수'를 보다 간략하게 나타낼 수 있다.      

## 2개 이상의 상수의 값
```java
package study.eenum;

import static study.eenum.DisplayType.*;

enum DisplayType {
    CRT("Cathode Ray Tube", "CRT is Good"),
    FPD("Flat Panel Display", "FPD is Good"),
    LCD("Liquid Crystal Display", "LCD is Good"),
    PDP("Plasma Display Panel", "PDP is Good"),
    LED("Light emitting diode", "LED is Good"),
    OLED("Organic Light Emitting Diode", "OLED is Good");

    private final String key;
    private final String value;
    
    public String getKey() {
        return key;
    }

    public String getValue() {
        return value;
    }

    DisplayType(String key, String value) {
        this.key = key;
        this.value = value;
    }


}

public class EnumTest {
    public static void main(String[] args) {
        System.out.println(CRT.getKey());
    }
}
``` 
열거형 상수의 값을 2개 이상 줄 수도 있다.          
앞선 내용과 마찬가지로 상수, 생성자, 변수, getter를 갯수에 맞게끔 정의해주면 된다.         

# enum 이 제공하는 메소드
Java의 `enum`은 기본적으로 제공되는 메소드가 몇 가지가 있다.      
    
```java
package com;

enum Direction { EAST,  WEST, SOUTH, NORTH}
                // 0     1     2      3

class EnumMain {
    public static void main(String[] args) {
        Direction east = Direction.EAST;
        Direction west = Direction.WEST;
        Direction south = Direction.SOUTH;
        Direction north = Direction.NORTH;

        System.out.println(east.toString());
        System.out.println(east.name());
        System.out.println("--------------");

        System.out.println(east.ordinal());
        System.out.println(west.ordinal());
        System.out.println(south.ordinal());
        System.out.println(north.ordinal());
        System.out.println("--------------");

        System.out.println(east.compareTo(Direction.EAST));
        System.out.println(east.compareTo(Direction.WEST));
        System.out.println("--------------");

        System.out.println(east.getDeclaringClass());
        System.out.println("--------------");

        System.out.println(east.valueOf("EAST"));
        System.out.println("--------------");

        Direction[] directions = east.values();

        for(Direction direction : directions){
            System.out.println(direction.toString());
        }
       
    }
}

/* 실행 결과  
 * EAST
 * EAST
 * --------------
 * 0
 * 1
 * 2
 * 3
 * --------------
 * 0
 * -1
 * --------------
 * class com.Direction
 * --------------
 * EAST
 * --------------
 * EAST
 * WEST
 * SOUTH
 * NORTH
 */
```    
|메서드 이름|설명|   
|----------|----|
|toString()|해당 상수의 이름을 문자열로 반환한다.|      
|name()|해당 상수의 이름을 문자열로 반환한다.|
|compareTo()|정렬의 기준을 위한 메서드이다.<br>비교 대상보다 순서가 빠르면 -1, 같으면 0, 느리면 1을 반환한다.<br> 정렬 순서는 상수가 선언된 순서가 디폴트로 지정되어 있다.|
|ordinal()|상수의 선언 순서에 따른 인덱스(Zero based)값을 반환한다.<br>Enum 안에는 `private final int ordinal;`가 정의되어있고 이를 사용한다.|        
|valueOf()|인자로 받은 이름과 같은 Enum값으로 반환한다.|       
|values()|선언된 모든 Enum값을 순서대로 배열에 담아서 반환한다.|      
      
이 메소드들은 overriding도 가능하므로 참고하도록 하자.    
     
**toString() 과 name()의 차이**
```java
    public final String name() {
        return name;
    }

   public String toString() {
        return name;
    }
```
* `toString()`과 `name()`은 같은 값을 반환한다.   
* 그렇다면 차이는 무엇일까?      
* `name()`은 `final`로 선언된 메서드로 오버라이딩이 불가능하다.      
* `toString()`은 일반적인 Object 클래스의 메서드로 우리가 오버라이딩할 수 있다.   
* [참고](https://stackoverflow.com/questions/18031125/what-is-the-difference-between-enum-name-and-enum-tostring)     

 
# java.lang.Enum
# EnumSet
# enum 싱글톤 

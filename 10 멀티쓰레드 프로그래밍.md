# 들어가면서   
> 목표 : 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.    

# 프로세스와 쓰레드
프로세스는 운영체제로부터 자원을 할당받는 **작업의 단위**이다.         
쓰레드는 프로세스가 할당 받은 자원을 이용하는 **실행 단위**이다.     
      
![01AEC5FD-FDBA-46FE-8DC5-AC667A9AF33E](https://user-images.githubusercontent.com/50267433/105000222-69eee400-5a71-11eb-96ed-e3b4fc81802f.png)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)
         
비유 하자면 야구장에서 **맥주를 파는 사업**을 **프로세스**라 하고          
본사로부터 **맥주를 할당 받아서 판매하는 사람**이 **쓰레드**이다.           
        
![40850_76494_06](https://user-images.githubusercontent.com/50267433/105001975-eb477600-5a73-11eb-85fc-3d9e4f29b563.jpg)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)      
     
여기서 **맥주 사업과 더불어 치킨 사업까지** 같이 할 경우 이를 **멀티 태스킹, 멀티 프로세스**라 말하고             
**맥주를 할당 받아서 판매하는 사람이 여러명**일 경우 이를 **멀티 쓰레드**라고 말할 수 있다.               
                       
우리가 실행하는 **자바 애플리케이션**은 하나의 프로세스이다.              
애플리케이션 내에서 실행되는 **작업**은 하나의 쓰레드이다.              
그리고 애플리케이션 내에서 작업을 여러개 실행할 경우 이는 멀티 쓰레드가 된다.           
           
# Thread 클래스와 Runnable 인터페이스     
자바에서 쓰레드를 구현할 수 있는 방법은 2가지이다.   

1. Thread 클래스를 상속하여 구현하는 방법        
2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법     
  
## Thread 클래스    
**Thread 클래스**      
```java
class Thread implements Runnable {
    ...     // 생략
    
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null, true);
    }
    
    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }
        
    /* What will be run. */
    private Runnable target;
        
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    ...     // 생략
}
```

* `Thread` 클래스는 정의된 클래스로 `Runnable` 인터페이스를 구현한다.                     
* 당연한 얘기이겠지만, Thread와 관련된 변수 및 상수 그리고 메서드를 제공한다.          
* `Runnable` 인터페이스를 구현하기에 `run()` 메서드가 실제로 정의되어 있는 모습이다.      
* 하지만, `run()` 메서드는 Runnable 인터페이스를 구현한 구현체의 `run()`메서드를 실행만 한다.   
* 즉, 개발자가 Runnable 인터페이스의 구현체를 생성자나 `init()`을  통해 주입시켜줘야 한다.     
          
**Thread 클래스를 상속하여 구현하는 방법**
```java
class MyThread extends Thread {
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```
앞선 코드에서 보았듯이 Thread 클래스는 의존하는 구현체의 run()을 실행한다.           
그렇기에 상속을 이용한 쓰레드를 구현하고자 한다면               
사용자가 직접 `run()` 메서드를 오바리이딩해서 구현해야한다.                

## Runnable 인터페이스     
**Runnable 인터페이스**         
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
* `Runnable` 인터페이스는 `run()`메서드만을 가지고 있는 함수형 인터페이스다.      
* 클래스에서 `Runnable` 인터페이스를 구현해서 `run()` 정의하고 사용해야한다.     
    
**2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법**   
```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
`Runnable` 인터페이스를 구현했다고 해서 쓰레드가 생성되는 것은 아니다.      
`Runnable` 인터페이스 구현체를 Thread 클래스에 생성자를 통해 주입하고    
`Thread` 클래스를 이용해서 쓰레드를 실행해야 한다.  

```java
class Sample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("작업 내용"));
    }
}
```
`Runnable` 인터페이스는 함수형 인터페이스이기에 람다식을 사용할 수 있다.       
     
## Thread VS Runnable    
결론부터 말하자면 `Runnable` 인터페이스를 구현하는 것이 주로 선호되는 방법이다.   
   
```java   
class MyThread extends Thread {     // 상속을 추가로 못하게 된다.    
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```

Runnable을 구현하면 클래스가 유연해진다.   
자바는 단일 상속만 지원하므로 하나의 클래스만 상속할 수 있다.                         
Thread 클래스를 상속받아 `run()`을 구현한 클래스는 더 이상 상속 받을 수 없다.  

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class MyRun2 implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
         thread = new Thread(new MyRun2());           // 작업 교체  
     }
}
```
또한, Thread 상속받아 구횬하면 수행하려는 작업은 항상 스레드내에만 존재하게된다.       
그러나 Runnable을 구현하는 경우 다양한 Thread 클래스에서 사용할 수 있다.     
그렇기 때문에, 상속에 자유로운 Runnable 인터페이스를 구현하는 것을 선호한다.           

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
또한, 인터페이스로 구현하면 실행 코드와 쓰레드 구현을 명확하게 구분할 수 있다.     

# 쓰레드의 상태    
# Main 쓰레드                             
프로그램은 쓰레드 없이 실행할 수 없으므로 적어도 하나의 쓰레드가 필요하다.                     
`JVM`은 각 프로그램에 대한 기본 쓰레드를 제공하며 이를 `Main 쓰레드`라고 부른다.              
          
우리가 애플리케이션을 구동시킨다면 제일 먼저 `main()` 가 호출된다.              
`main()`은 프로그램을 실행하기 위한 시작 지점이다.                        
따라서, `main()`가 시작하면 `JVM`은 `Main 쓰레드`를 실행시킨다.       





# 쓰레드의 우선순위       
Thread 클래스는 우선순위(priority)라는 멤버변수를 가지고 있다.     
이 우선순위의 값에 따라 쓰레드가 얻는 실행 시간이 달라진다.   
쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여    
**특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.**       
   
주로, 시각적인 부분이나 사용자에게 빠르게 반응해야하는 작업을 하는 쓰레드의 우선순위는    
다른 작업을 수행하는 쓰레드에 비해 우선순위가 높다.       
(파일/채팅이 있다면, 파일보다 채팅이 우선순위가 높아야하는 경우가 많다.)          
  
**쓰레드의 우선순위 지정하기**    
쓰레드의 우선순위와 관련된 메서드와 상수는 다음과 같다.   
   
```java
void setPriority(int newPriority){}   // 쓰레드의 우선순위를 지정한 값으로 변경한다.   
int getPrirority(){}                  // 쓰레드의 우선순위를 반환한다.  
 
public static final int MAX_PRIORITY = 10;      // 최대우선순위    
public static final int MIN_PRIORITY = 1;       // 최소우선순위   
public static final int NORM_PRIORITY = 5;      // 보통우선순위  
```
쓰레드가 가질 수 있는 우선순위의 범위는 **1~10**이며 숫자가 높을수록 우선순위가 높다.        
  
한 가지 더, 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.     
`main()`을 수행하는 쓰레드는 우선순위가 5이므로        
**`main()` 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5가 된다.**       

```java
class ThreadEx {
    public static void main(String args[]) {
        ThreadOne th1 = new ThreadOne();      // 쓰레드 생성
        ThreadTwo th2 = new ThreadTwo();      // 쓰레드 생성

        th2.setPriority(7);

        System.out.println("Priority of th1(-) : " + th1.getPriority() );
        System.out.println("Priority of th2(|) : " + th2.getPriority() );
        th1.start();
        th2.start();
    }
}

class ThreadOne extends Thread {
    public void run() {
        for(int i=0; i < 300; i++) {
            System.out.print("-");
            for(int x=0; x < 10000000; x++);
        }
    }
}

class ThreadTwo extends Thread {
    public void run() {
        for(int i=0; i < 300; i++) {
            System.out.print("|");
            for(int x=0; x < 10000000; x++);
        }
    }
}

/* 싱글코어 실행 결과  
* -||-|||||||||||||||||||||||||||||||||||||||||||||||||||---------------------
* ----------------------------------------------------||||||||||||----||||||||
* ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
* ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
* ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||--
* -------------------------------------------------------------------------
* -------------------------------------------------------------------------
* -------------------------------------------------------------------------
*/

/* 멀티코어 실행 결과  
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
*/
```
쓰레드의 우선순위를 변경하고 싶다면, 쓰레드를 실행하기 전에만 변경해야 한다.    
    
![우선순위가 같을 경우](https://user-images.githubusercontent.com/50267433/105354689-41fbae00-5c34-11eb-9954-6409753029b6.PNG)    
   
위 그림은 윈도우에서 `싱글코어`로 2개의 쓰레드로 2개의 작업을 실행했을 때의 결과이다.    
우선 순위가 같은 경우 각 쓰레드에게 거의 같은 양의 실행 시간이 주어진다.     
   
![우선순위가 다를 경우](https://user-images.githubusercontent.com/50267433/105354857-81c29580-5c34-11eb-9a54-5f7da7ad3ded.PNG)     
   
우선 순위가 다르다면 우선순위가 높은 쓰레드에게 상대적으로 많은 실행시간이 주어진다.  
그렇기에 결과적으로 A가 B보다 더 빨리 작업을 완료할 수 있다.  
   
![우선순위가 같을 경우](https://user-images.githubusercontent.com/50267433/105354689-41fbae00-5c34-11eb-9954-6409753029b6.PNG)       
   
그러나, `멀티코어`에서는 쓰레드의 우선순위에 따른 차이가 거의 없다.                     
쓰레드에 높은 우선순위를 주면 더 많은 실행시간과 기회를 갖는 것을 기대하기는 어렵다.            
**자바는 쓰레드의 우선순위에 따라 많은 시간과 기회를 주는 것을 강제하지 않는다.**           
그저 JVM에게 **메모리,시간이 제한적이라면 우선적으로 처리하도록 권유하는 것 뿐이다.**      
    
굳이, 우선순위에 차등을 두어 스레드를 실행하려면,      
특정 OS의 스케쥴링 정책과 JVM의 구현을 직접 확인해봐야 한다.      
만일 확인한다 하더라도 OS의 스케쥴러에 종속적이라서 예측만 가능할 정도이다.    

차라리 쓰레드에 우선순위를 부여하는 대신 작업에 우선순위를 두어 `PriorityQueue`에 저장해 놓고,      
우선순위가 높은 작업이 먼저 처리되도록 하는 것이 나을 수 있다.        
      
**필자의 생각 :**   
만약 우선순위가 10 이상이면 어떻게 되지? : [참고바람](https://stackoverflow.com/questions/21794411/thread-priority-for-more-than-10-threads-in-java)     
우선 결론만 말하자면, 불가능하다.       
쓰레드의 우선순위는 절대적인 것이 아니며, **JVM에게 권유를 하는 것이다.**        
또한, 만약에 10개 이상의 쓰레드를 동시에 사용해야 하는 경우가 발생했다면                  
이는 애초에 프로그램을 잘못 설계 했을 가능성이 높다.                 

# 쓰레드의 동기화
멀티 쓰레드의 경우,            
여러 쓰레드가 동일한 프로세스 내의 자원을 공유해서 사용하기 때문에              
`Race Condition`과 같이 쓰레드간의 작업에 영향을 줄 수 있다.          
즉, 원래 의도했던 결과가 아닌 **엉뚱하고 치명적인 결과를 불러일으킬 수 있다.**   
      
이러한 문제를 발생시키지 않기 위해서는         
특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다.        
그래서 도입된 개념이 바로 **임계영역(critical section)** 과 **잠금(lock)** 이다.      
  
![1](https://user-images.githubusercontent.com/50267433/105116605-69585b00-5b0e-11eb-97e9-a2e7bc89eaea.PNG)    
         
공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고,              
공유 데이터가 가지고 있는 `lock`을 획득한 하나의 쓰레드만 코드를 수행할 수 있게 한다.         
그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만       
다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 된다.    
  
이처럼 **한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것**을      
**'쓰레드의 동기화'** 라고 부른다.           
  
## synchronized를 이용한 동기화     
`synchronized` 키워드는 임계 영역을 설정하는데 사용된다.     
`synchronized` 키워드를 사용해 임계 영역을 설정하는 방법은 2가지가 있다.     

1. 메서드 전체를 임계 영역으로 지정 
2. 특정한 영역을 임계 영역으로 지정 
    
```java
// 1. 메서드 전체를 임계 영역으로 지정 
public synchronized void calcSum() {
    // ...
}

// 2. 특정한 영역을 임계 영역으로 지정 
synchronized (객체_참조변수) {
    // ...
}
```

**메서드 전체를 임계 영역으로 지정**   
```java
    public synchronized  void withdraw(int money) {
        if(balance >= money) {
            try {
                Thread.sleep(1000);
            } catch (Exception e){}
            balance -= money;
        }
    }
```
'메서드 전체를 임계 영역으로 지정'하는 방법은       
메서드 앞에 `synchronized` 키워드를 붙이는 것이다.        
`synchronized` 키워드를 붙이면 메서드 전체가 임계 영역으로 설정된다.    
   
쓰레드는 `synchronized 메서드`가 호출된 시점부터      
**해당 메서드가 포함된 객체의 `lock`** 을 얻어 작업을 수행하다가      
메서드가 종료되면 `lock`을 반환한다.        
        
**특정한 영역을 임계 영역으로 지정**            
```java
    public void withdraw(int money) {
        synchronized(this){
            if(balance >= money) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e){}
                balance -= money;
            }    
        }
    }
```
메서드 내의 코드 일부를 블럭`{}`으로 감싸고 이를 임계 영역으로 설정한다.             
이때 **참조변수는 락을 걸고자하는 객체를 참조하는 것이어야 한다.**          

우리는 2가지 방법을 통해 임계 영역을 설정해주었다.   
2가지 방법 모두 lock의 획득과 반납이 모두 자동적으로 이루어진다.   
      
임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면             
메서드 전체 보다 `synchronized 블럭`으로 임계 영역을 최소화하여 락을 거는 것이 좋다.          
      
**예시**      
은행계좌에서 잔고를 확인하고 임의의 금액을 출금하는 코드를 살펴볼 것이다.      
아래 코드를 보면 잔고가 출금하려는 금액보다 큰 경우에만 출금하도록 정의되어 있다.      
```java
    public void withdraw(int money) {
        if (balance >= money) {                 // 여긴 통과했는데
            try { 
                Thread.sleep(1000); 
            } 
            catch (Exception e) { }
            balance -= money;                   // 여기를 빼앗겼다.   
        }
    }
```
하지만, 실행 결과를 보면 잔고(balance)가 음수인 것을 볼 수 있다.       
그 이유는 한 쓰레드가 if문의 조건식을 통과하고 출금하기 바로 직전에           
다른 쓰레드가 끼어 들어서 출금을 먼저 했기 때문이다.           
즉, 서로 자원을 먼저 사용하려고 뺏으려 경쟁하는 `Race Condiion`이 발생했다.       
           
쉽게 설명하면 두 쓰레드 모두 `if 문`을 통과했지만,             
어느 한 쓰레드가 먼저 출금해 잔고가 마이너스가 된 상황이다.            
그렇기에 잔고를 확인하는 `if 문`과 출금하는 문장은 하나의 임계 영역으로 묶여져야 한다.     

```java
    public synchronized  void withdraw(int money) {
        if(balance >= money) {
            try {
                Thread.sleep(1000);
            } catch (Exception e){}
            balance -= money;
        }
    }
```
```java
    public void withdraw(int money) {
        synchronized(this){
            if(balance >= money) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e){}
                balance -= money;
            }    
        }
    }
```
* 앞서 배웠던 2가지 방법으로 임계 영역을 지정해 동기화를 진행할 수 있다.          

```java
package com.ssafy.algo;

class ThreadEx22 {
    public static void main(String[] args) {
        Runnable r = new RunnableEx22();
        new Thread(r).start();
        new Thread(r).start();
    }

}

class Account {
    private int balance = 1000;

    public int getBalance() {
        return balance;
    }

    public void withdraw(int money) {
        synchronized (this){
            if (balance >= money) {
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) { }
                balance -= money;
            }
        }
    }
}

class RunnableEx22 implements Runnable{
    Account acc = new Account();

    @Override
    public void run() {
        while (acc.getBalance() > 0){
            int money = (int)(Math.random() * 3 +1) * 100;
            acc.withdraw(money);
            System.out.println("balance:"+acc.getBalance());
        }
    }
}

/* 실행 결과
 * 
 * balance:900
 * balance:800
 * balance:700 
 * balance:400
 * balance:200
 * balance:0
 * balance:0
 */
```
   
## Lock과 Condition을 이용한 동기화    
동기화할 수 있는 방법은 `synchronized` 키워드 외에도          
`java.util.concurrent.locks` 패키지가 제공하는 `lock` 클래스들을 이용하는 방법이 있다.       
  
`synchronized`블럭으로 동기화를 하면 자동적으로 lock이 잠기고 풀리기 때문에 편하다.      
심지어 `synchronized`블럭 내에서 예외가 발생해도 lock은 자동적으로 풀린다.          
하지만, 때로는 같은 메서드 내에서만 `lock`을 걸수 있다는 제약이 불편하기도 하다.    
그럴 때 lock 클래스를 사용한다.  
   
lock 클래스의 종류는 3가지가 있다.    

* **ReetrantLock :** 재진입이 가능한 lock, 가장 일반적인 배타 lock       
* **ReetrantReadWriteLock :** 읽기에는 공유적이고, 쓰기에는 배타적인 lock     
* **StampedLock :** ReetrantReadWriteLock에 낙고나적인 lcok의 기능을 추가   
     
**ReetrantLock**    
```java
    private int balance = 1000;
    private ReentrantLock lock = new ReentrantLock();

    public int getBalance() {
        lock.lock();                            // lock 시작
        int curBalance = this.balance;
        try {
            curBalance = this.balance;
        } finally {
            lock.unlock();                      // lock 종료
        }
        return curBalance;
    }
```
* 가장 일반적인 lock 이다.       
* **재진입(ReetrantLock)** 이라는 이름 그대로       
특정 조건에서 lock을 풀고 나중에 다시 lock을 얻고 이후의 작업을 수행할 수 있다.       
* `ReetrantLock`는 배타적인 lock이라서 무조건 lock이 있어야만 코드를 수행할 수 있다.  
  
**ReetrantReadWriteLock**     
```java
    private int balance = 1000;
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    
    public int getBalance() {
        lock.readLock().lock();                 // 읽기 lock 시작
        int curBalance = this.balance;
        try {
            curBalance = this.balance;
        } finally {
            lock.readLock().unlock();            // 읽기 lock 종료
        }
        return curBalance;
    }
    
    public void withdraw(int money) {
        lock.writeLock().lock();                // 쓰기 lock 시작
        try {
            if (balance >= money) {
                balance -= money;
            }
        }finally {
            lock.writeLock().unlock();          // 쓰기 lock 종료
        }
    }    
```
* `읽기를 위한 lock`과 `쓰기를 위한 lock`을 제공한다.         
* `ReetrantReadWriteLock`는 `읽기 lock`이 걸려있어도               
**다른 쓰레드가 읽기 lock을 중복해서 걸고 읽기를 수행할 수 있다.**                
* 읽기는 내용을 변경하지 않으므로 동시에 여러 쓰레드가 읽어도 문제가 되지 않는다.          
* 그러나 `쓰기 lock`을 걸거나 사용하는 경우, 다른 쓰레드와의 중복은 불가능하다.        
  
**StampedLock**    
```java
    private int balance = 1000;
    private StampedLock lock = new StampedLock();

    public int getBalance() {
        long stamp = lock.tryOptimisticRead();        // 낙관적 읽기 lock을 건다.
        int curBalance = this.balance;                // 공유데이터인 balance를 가져온다.  

        if (lock.validate((stamp))) {                 // 쓰기 lock에 의해 낙관적인 읽기 lock이 풀렸는지 확인
            stamp = lock.readLock();                  // lock이 풀렸으면, 일반 읽기 lock을 얻으려고 기다린다.   

            try {
                curBalance = this.balance;            // 공유 데이터를 다시 읽어온다.  
            } finally {                   
                lock.unlockRead(stamp);               // 읽기 lock을 푼다.  
            }

        }
        return curBalance;                            // 낙관적 읽기 lock이 풀리지 않으면 곧바로 읽어온 값을 반환   
    }
```   
* lock 을 걸거나 해지할 때 스탬프(long 정수값)사용하며,        
* 읽기와 쓰기를 위한 lock외에 '낙관적 읽기 lock'가 추가된 것이다.       
* 읽기 lock이 걸려있으면, 쓰기 lock을 사용하기 위해 읽기 lock이 풀리기를 기다려야 한다.     
* 하지만, '낙관적인 읽기 lcok'를 사용하면 '쓰기 lock'에 의해 바로 풀린다.       
* 그래서 만약, '낙관적인 읽기 lcok'에 실패한다면, 읽기 lock을 다시 읽어와야 한다.      
* 무조건 읽기 lock 을 걸지 않고,       
**쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후에 읽기 lock을 거는 것이다.**       





# RACECONDITION




# 데드락


# JIT Compiler    
      
**JVM의 핵심 기능**이라고 할 수 있는 `JIT Compiler`에 대해서 알아보고자 합니다.       
                                        
`JIT`의 의미는 `Just-In-Time`이라는 이름 그대로 `그 순간`을 의미합니다.    
한국말로, `적시생산시스템`이라 말할 수 있으며         
**`필요할 때, 필요한 만큼만 생산한다.`** 라는 철학을 가지고 있습니다.        
     
```  
단어의 어원 미국의 록히드 항공사가 슈퍼마켓 방식을 생산에 도입함으로써 상당한 효과를 봤다는        
홍보물을 본 도요다 자동차를 비롯한 일본 자동차 회사에서 자동차 생산에 적용한 데서 시작되었습니다.        
필요한 것을, 필요한 때에, 필요한 만큼 만들어라라는 모토를 가지고 있습니다.   
```        
         
**🤔 그렇다면 `JIT Compiler`는 어떤 것을 생산하는 것일까요?**            
바로, 런타임시에 CPU에서 직접 사용할 `바이너리 코드를`를 만드는 작업을 합니다.      
     
# 컴파일과 인터프리트           
CPU는 **어셈블리나 바이너리코드라고 불리는 특정 명령만을 실행시킬 수 있습니다.**            
즉, CPU가 실행하는 `프로그램들은 이러한 언어로 변환되어 실행되어야 한다`는 의미기도 합니다.      
   
* **컴파일형 언어 :** `C++`, `Forttarn`과 같은 언어는 한 번에 모든 코드를 읽고 해석         
* **인터프리터 언어 :** `PHP`, `Perl`, `python`과 같은 언어는 한 번에 한줄의 코드만 읽고 해석  
                                           
`Java`는 흔히들 `컴파일 언어`라고 잘못 알고 있는 경우가 많은데 실은 **`인터프리터 언어`입니다.**                      
그렇기에 **한 번에 한 줄씩 수행하여 느리다는 인터프리터의 단점을 그대로 가지고 있습니다.**              
                                                                                   
`Java`는 여기서 절충안을 찾으려고 시도합니다.                 
바이트 코드를 `JIT Complier` 한 줄씩 읽으면서 `바이너리 코드`로 `변환`을 하는 방식을 채택했습니다.                    
여기까지는` Java Interpreter` 와 크게 다를게 없지만 **`JVM`의 `CodeCache`에 `Caching`해놓습니다.**                   
그렇기에, 같은 코드가 나오도라도 매번 바이너리 코드로 해석 작업을 하는 `Java Interpreter`와 달리,                
같은 코드가 나온다면 `Caching`을 사용하여 **다시 번역할 필요 없이 해당 바이너리 코드를 가져와 사용합니다.**                      
   
* **참고 - 자바가 인터프리터를 채택한 이유?:**               
프로그램이 커질 수록 컴파일 언어는 컴파일 시간이 길어진다는 문제가 있다.     
반면에, 인터프리터를 사용하면 해당 부분만 수정을 하면 된다는 이점이 있다.      
사실 자바 뿐만 아니라 70%의 프로그래밍 언어가 이러한 이유때문에 인터프리터를 채택하고 있다.  
         
## 핫스팟 컴파일     
[파레토 법칙](https://ko.wikipedia.org/wiki/%ED%8C%8C%EB%A0%88%ED%86%A0_%EB%B2%95%EC%B9%99)처럼, 일반적인 프로그램은 전체 코드 중 일부만 자주 실행되며        
애플리케이션의 성능은 이 일부가 얼마나 빠르게 실행되는가에 의해 좌우됩니다.              
그리고 이러한 영역을 애플리케이션의 `핫스팟`이라고 합니다. (코드가 많이 실행될수록 핫해진다는 의미입니다.)       
          
`JIT Compiler`는 `Hot Spot Detection` 이라는 기술을 이용해   
일정시간 동안, 인터프리터가 코드를 해석하며 컴파일하는 과정에서           
충분할 정도로 자주 호출되는 메소드가 무엇인지 알아내고          
해당 메소드를 핫스팟이라고 판단하여 컴파일을 진행합니다.(최적화도)       
그리고 이러한 핫스팟을 식별하고 컴파일 하는 방법을 `핫스팟 컴파일`이라고 부릅니다.  

      
만약 중복된 코드가 아닌 모든 코드를 컴파일하면 안되는 걸까? 🤔   
모든 코드를 컴파일하는 방식의 수행 시간 자체는 빠르지만   
프로그램 크기가 커지고 기기별 이식성이 떨어진다는 문제점이 있다.  
그렇기에 JVM에서는 기본으로 Interpreter 방식을 사용하지만,  
여러 번의 중복이 발생하는 경우에만 Hot Spot Detection 방식을 사용한다.   

 
`JVM`은 코드를 실행하자 마자 바로, `코드 컴파일`을 하지 않습니다.       
그리고 여기에는 기본적인 이유가 두 가지가 있습니다.      
           
* **첫째 :**        
  코드가 한 번만 실행된다면 컴파일은 헛수고다.       
  컴파일해서 컴파일된 코드를 한번만 실행하는 것보다(컴파일 하는 시간 때문에)    
  자바 바이트코드를 인터프리트하는 편이 더 빠를 것이다. 
    
* **둘째 :**     
  최적화 때문이다.     
  `JVM`이 특정 메소드나 루프를 실행하는 시간이 길어질 수록 코드에 대해 얻어지는 정보가 많다.    
  이를 통해 JVM이 코드를 컴파일할 때 최적화를 많이 적용할 수 있다.
   
```java  
b = obj1.equals(obj2); 
```
여기는 나중에 채우자  

    
# JIT Compiler의 종류         
`JIT Compiler`는 `서버`와 `클라이언트` 두 가지 형태로 나눠지며,      
사용할 형태는 프로그램이 수행되는 기간과 초기 스타트업 시간의 중요도를 바탕으로 선택합니다.     
(현재 사용하는 컴파일러 종류는 java -version을 보면 확인 가능합니다.)   
                      
**Client Compiler**        
- `Start-up` 시간이 빠르며, 최적화를 위한 대기시간이 짧습니다      
- 하지만 최적화가 덜하기 때문에 `코드실행은 서버 컴파일러가 더 빠르   
            
**Server Compiler**            
- 클라이언트 컴파일러에 비해 `Start-up`이 느립니다.    
- 하지만, 컴파일 전에 많은 정보를 수집하여 **최적화에 중점을 두고 있습니다.**              
- 그리고, 서버 컴파일러는 절대로 모든 코드를 컴파일하지 않습니다.  (이유에 대해서는 찾아봐야겠습니다.)          

    
**Tiered Compile ( -server -xx:+TieredCompilation )**     
- JDK 7 부터 도입되었으며, JDK 8 부터 기본 옵션으로 적용되었습니다.  
- **클라이언트 컴파일러로 스타트업 시간을 빠르게 하고, 많이 쓰이는 부분을 서버 컴파일러로 다시 컴파일하여 대체합니다.**    
- 이러한 `트레이드 오프`하는 과정에서 역최적화 후 서버 컴파일러로 재컴파일 됩니다.    
- 재컴파일 되는 시간은 성능에 영향을 줄 정도로 크지 않습니다.
- "-server -xx:+TieredCompilation" 옵션으로 명시합니다.       
    
**시간 비교**
- 스타트업 시간 :  -client < -xx:+TieredCompilation < -server
- 코드실행 시간 : - xx:+TieredCompilation = -server < -client
- 상황에 따라 알맞은 컴파일러를 지정해서 사용하도록 합시다!       
     
   
# CoadCache 튜닝   
앞서 말했듯이, `Coad Cache`는 재사용될 바이너리 코드가 저장되는 공간입니다.      
하지만, 가득 차게 되면 `JVM`은 더 이상 코드를 추가적으로 바이너리 코드로 컴파일 할 수 없습니다.  
이 말은 애플리케이션의 많은 양의 부분이 인터프리터로 실행될 수 있다는 말입니다.     
        
`Client Compiler`를 사용하는 대형 프로그램이라면 `Coad Cache`사이즈를 늘릴 필요가 있습니다.      
그러나, 필요로 하는 `Coad Cache`가 어느 정도인지 알아내기에 적합한 매커니즘은 따로 없습니다.   
그렇기에 `Coad Cache`의 최대 크기를 `-XX:ReservedCodeCacheSize=N` 플래그를 통해    
기존 설정된 값의 2배 또는 4배로 늘려보는 방법밖에 없습니다.             
(서버 컴파일러의 경우에는 몇개의 소수 클래스만 컴파일 되므로 코드 캐시를 채울 일은 그다지 없습니다.)   

**그러면 최대 코드 캐시로 실제 큰 값을 지정하여 공간이 부족하지 않게 하면 되지 않을까? 라고 생각할 수 있습니다.**
    
   
이는 대상 머신에서 사용할 수 있는 가상 메모리의 크기에 따라 달려 있습니다.        
1GB로 CoadCache 사이즈를 명시했다면 JVM은 네이티브 메모리 크기를 1GB로 예약합니다.        
이 메모리는 필요로 하기 전까지 할당되진 않겠지만 예약되어 있으므로       
이 메모리를 제외한 나머지 메모리에서 자원을 사용할 것입니다.      
즉 예약 조건을 만족시키기 위해 머신에 이용 가능한 가상 메모리가 충분하다면 사용하면 됩니다.   

코드 캐시는 JVM 내의 대부분의 메모리와 같이 관리되며 초기 크기가 있습니다.   
초기 크기부터 시작해서 캐시가 차면 늘어나는 구조 입니다.
이런 캐시 리사이징은 백그라운드에서 일어나기 때문에 성능에는 실제로 영향을 주진 않습니다.

-XX:ReservedCodeCacheSize=N
코드 캐시의 최대 크기를 지정한다

-XX:InitialCodeCacheSize=N
초기 코드 캐시의 크기를 지정한다




위에서 일정기간동안 자주 사용되는 메소드들을 알아낸다고 했는데 일정기간은 JVM 옵션을 통해 설정가능하다. 컴파일된 코드가 올라가는 코드캐시의 크기도 설정 가능하다. 이러한 컴파일 관련 설정들은 옵션을 통해 바꿀 수 있으며 이러한 작업이 컴파일러를 튜닝하는 일이다. 
[출처] [JVM] JIT : Just In Time Compiler 개념 & 튜닝|작성자 뽕


 
 
 
 
 
   
      
      

# JIT Compiler     
> **JIT Compiler :** Just-In-Time Compiler         

# 들어가면서 
    
**JVM의 핵심 기능**이라고 할 수 있는 `JIT Compiler`에 대해서 알아보고자 합니다.       
                                        
`JIT`의 의미는 `Just-In-Time`이라는 이름 그대로 `그 순간`을 의미합니다.    
한국말로, `적시생산시스템`이라 말할 수 있으며         
**`필요할 때, 필요한 만큼만 생산한다.`** 라는 철학을 가지고 있습니다.        
     
```  
단어의 어원 미국의 록히드 항공사가 슈퍼마켓 방식을 생산에 도입함으로써 상당한 효과를 봤다는        
홍보물을 본 도요다 자동차를 비롯한 일본 자동차 회사에서 자동차 생산에 적용한 데서 시작되었습니다.      
```        
         
**🤔 그렇다면 `JIT Compiler`는 어떤 것을 생산하는 것일까요?**            
바로, 런타임시에 CPU에서 직접 사용할 `바이너리 코드를`를 만드는 작업을 합니다.      
     
# 컴파일과 인터프리트           
CPU는 **어셈블리나 바이너리코드라고 불리는 특정 명령만을 실행시킬 수 있습니다.**            
즉, CPU가 실행하는 `프로그램들은 이러한 언어로 변환되어 실행되어야 한다`는 의미기도 합니다.      
   
* **컴파일형 언어 :** `C++`, `Forttarn`과 같은 언어는 한 번에 모든 코드를 읽고 해석         
* **인터프리터 언어 :** `PHP`, `Perl`, `python`과 같은 언어는 한 번에 한줄의 코드만 읽고 해석  
                                           
`Java`는 흔히들 `컴파일 언어`라고 잘못 알고 있는 경우가 많은데 실은 **`인터프리터 언어`입니다.**                      
그렇기에 **한 번에 한 줄씩 수행하여 느리다는 인터프리터의 단점을 그대로 가지고 있습니다.**              
                                                                                   
`Java`는 여기서 절충안을 찾으려고 시도합니다.              
바이트 코드를 `JIT Complier` 한 줄씩 읽으면서 `바이너리 코드`로 `변환`을 하는 방식을 채택했습니다.                 
여기까지는` Java Interpreter` 와 크게 다를게 없지만 `JVM`의 `CodeCache`에 `Caching`해놓습니다.**                 
그렇기에, 같은 코드가 나오도라도 매번 바이너리 코드로 해석 작업을 하는 `Java Interpreter`와 달리,            
같은 코드가 나온다면 `Caching`을 사용하여 **다시 번역할 필요 없이 해당 바이너리 코드를 가져와 사용합니다.**                   
   
* **참고 - 자바가 인터프리터를 채택한 이유?:**               
프로그램이 커질 수록 컴파일 언어는 컴파일 시간이 길어진다는 문제가 있다.     
반면에, 인터프리터를 사용하면 해당 부분만 수정을 하면 된다는 이점이 있다.      
사실 자바 뿐만 아니라 70%의 프로그래밍 언어가 이러한 이유때문에 인터프리터를 채택하고 있다.  
         
## 핫스팟 컴파일     
[파레토 법칙](https://ko.wikipedia.org/wiki/%ED%8C%8C%EB%A0%88%ED%86%A0_%EB%B2%95%EC%B9%99)처럼, 일반적인 프로그램은 전체 코드 중 일부만 자주 실행되며        
애플리케이션의 성능은 이 일부가 얼마나 빠르게 실행되는가에 의해 좌우됩니다.              
그리고 이러한 영역을 애플리케이션의 `핫스팟`이라고 합니다. (코드가 많이 실행될수록 핫해진다는 의미입니다.)       
           
`JVM`은 코드를 실행하자 마자 바로, `코드 컴파일`을 하지 않습니다.       
그리고 여기에는 기본적인 이유가 두 가지가 있습니다.      
           
* **첫째 :**        
  코드가 한 번만 실행된다면 컴파일은 헛수고다.       
  컴파일해서 컴파일된 코드를 한번만 실행하는 것보다(컴파일 하는 시간 때문에)    
  자바 바이트코드를 인터프리트하는 편이 더 빠를 것이다. 
    
* **둘째 :**     
  최적화 때문이다.     
  `JVM`이 특정 메소드나 루프를 실행하는 시간이 길어질 수록 코드에 대해 얻어지는 정보가 많다.    
  이를 통해 JVM이 코드를 컴파일할 때 최적화를 많이 적용할 수 있다.
   
```java  
b = obj1.equals(obj2); 
```
여기는 나중에 채우자  


## 기본 튜닝 - 서버와 클라이언트 컴파일러     
JIT 컴파일러는 `서버`와 `클라이언트` 두 가지 형태로 나눠지며,       
사용할 형태는 애플리케이션이 실행 되고 있을 때 **해야 할 컴파일러 튜닝에 따라 결정됩니다**      

두 컴파일러의 주요 차이점은 코드 컴파일에 있어서 적극성의 유무 입니다.
  
클라이언트 컴파일러는 서버 컴파일러보다 먼저 컴파일하기 시작합니다.     
이는 서버 컴파일러보다 상대적으로 더 많은 코드를 컴파일 한다는 의미이며      
코드가 실행되기 시작하는 시간동안 클라이언트 컴파일러가 보다 더 빠를 것입니다.  

서버 컴파일러는 클라이언트 컴파일러보다 더 많은 정보를 바탕으로 컴파일을 하고 더 나은 최적화를 제공합니다.    
결국 애플리케이션이 장기간 작동을 한다면 서버 컴파일러가 클라이언트 컴파일러보다 더 빠를 것입니다.

각각의 컴파일러에 대한 트레이드 오프는   
프로그램이 수행되는 기간과 초기 스타트업 시간의 중요도를 바탕으로 선택합니다.

여기서 한가지 의문이 있을 수 있습니다.
JVM이 시작할 땐 클라이언트 컴파일러로 작동하다가 코드가 많이 호출되면 서버 컴파일러로 바꿀 순 없을까?    
이 기법은 티어드 컴파일(tiered compilation)이라고 합니다.

티어드 컴파일을 이용하면 코드는 먼저 클라이언트 컴파일러로 컴파일 되고 많이 쓰이게 되면 역최적화 후 서버 컴파일러로 재컴파일 됩니다.    
재컴파일 되는 시간은 성능에 영향을 줄 정도로 크지 않습니다.

티어드 컴파일은 자바 7부터 릴리즈 되었으며 자바 8에서는 기본으로 사용할 수 있습니다.





 
 
 
 
 
 
   
      
      

# JIT Compiler     
> **JIT Compiler :** Just-In-Time Compiler         
